import { supabase } from "../../../../config/supabase";

/**
 * Fetches an article for a given genre and usage type (daily | mock),
 * enforces user-aware cooldown-based reuse rules,
 * updates usage metadata,
 * and returns the selected article.
 */
export async function fetchArticleForUsage(params: {
    genre: string;
    usageType: "daily" | "mock";
    user_id?: string; // Required for mock usage to enable user-specific filtering
}) {
    const { genre, usageType, user_id } = params;

    console.log(
        `ðŸš€ [ARTICLE] Fetching article | genre=${genre}, usage=${usageType}, user_id=${user_id || 'N/A'}`
    );

    const now = new Date().toISOString();

    // 100-day cooldown window
    const cooldownDate = new Date(
        Date.now() - 100 * 24 * 60 * 60 * 1000
    ).toISOString();

    /**
     * STEP 1: For mock usage, fetch user's article history
     */
    let userArticleIds: string[] = [];

    if (usageType === "mock" && user_id) {
        console.log(`ðŸ“Š [ARTICLE] Fetching user's exam history for user_id=${user_id}`);

        // Fetch all exam papers generated by this user
        const { data: userExams, error: examsError } = await supabase
            .from("exam_papers")
            .select("id")
            .eq("generated_by_user_id", user_id);

        if (examsError) {
            console.warn("[ARTICLE] Error fetching user exams:", examsError);
        } else if (userExams && userExams.length > 0) {
            const userExamIds = userExams.map(e => e.id);
            console.log(`ðŸ“‹ [ARTICLE] Found ${userExamIds.length} exams for this user`);

            // Fetch all passages (and their article_ids) from user's exams
            const { data: userPassages, error: passagesError } = await supabase
                .from("passages")
                .select("article_id")
                .in("paper_id", userExamIds);

            if (passagesError) {
                console.warn("[ARTICLE] Error fetching user passages:", passagesError);
            } else if (userPassages) {
                // Get unique article IDs using Array.from to avoid downlevelIteration error
                const uniqueArticleIds = new Set(userPassages.map(p => p.article_id).filter(Boolean));
                userArticleIds = Array.from(uniqueArticleIds);
                console.log(`ðŸš« [ARTICLE] Excluding ${userArticleIds.length} articles already used by this user`);
            }
        } else {
            console.log(`âœ¨ [ARTICLE] New user - no previous exams found`);
        }
    }

    /**
     * STEP 2: Fetch all articles for this genre
     */
    let query = supabase
        .from("articles")
        .select("*")
        .eq("genre", genre)
        .eq("is_archived", false);

    const { data: allArticles, error: fetchError } = await query;

    if (fetchError) {
        console.error("[ARTICLE] Fetch error:", fetchError);
        throw new Error(`Failed to fetch articles: ${fetchError.message}`);
    }

    if (!allArticles || allArticles.length === 0) {
        console.error(
            `[ARTICLE] No articles found | genre=${genre}`
        );
        throw new Error(
            `No articles found for genre=${genre}`
        );
    }

    console.log(`ðŸ“š [ARTICLE] Total articles in genre: ${allArticles.length}`);

    /**
     * STEP 3: Filter and prioritize articles based on usage type
     */
    let eligibleArticles: typeof allArticles = [];

    if (usageType === "daily") {
        // For daily: prefer never-used, or allow custom_exam articles past cooldown
        eligibleArticles = allArticles.filter((article) => {
            const neverUsed = !article.used_in_daily && !article.used_in_custom_exam;
            const customExamReusable =
                article.used_in_custom_exam &&
                article.last_used_at &&
                new Date(article.last_used_at) < new Date(cooldownDate);

            return neverUsed || customExamReusable;
        });
    } else {
        // For mock: Use 3-tier priority system

        // Priority 1: Articles used in custom mocks but NOT by this user
        const usedByOthersArticles = allArticles.filter(article =>
            article.used_in_custom_exam &&
            !userArticleIds.includes(article.id)
        );

        // Priority 2: Never-used articles (excluding user's articles)
        const neverUsedArticles = allArticles.filter(article =>
            !article.used_in_daily &&
            !article.used_in_custom_exam &&
            !userArticleIds.includes(article.id)
        );

        // Priority 3: Daily articles past cooldown (excluding user's articles)
        const dailyReusableArticles = allArticles.filter(article =>
            article.used_in_daily &&
            article.last_used_at &&
            new Date(article.last_used_at) < new Date(cooldownDate) &&
            !userArticleIds.includes(article.id)
        );

        // Select from priorities in order
        if (usedByOthersArticles.length > 0) {
            eligibleArticles = usedByOthersArticles;
            console.log(`âœ… [ARTICLE] Priority 1: ${usedByOthersArticles.length} articles used by others`);
        } else if (neverUsedArticles.length > 0) {
            eligibleArticles = neverUsedArticles;
            console.log(`âœ… [ARTICLE] Priority 2: ${neverUsedArticles.length} never-used articles`);
        } else if (dailyReusableArticles.length > 0) {
            eligibleArticles = dailyReusableArticles;
            console.log(`âœ… [ARTICLE] Priority 3: ${dailyReusableArticles.length} daily reusable articles`);
        } else {
            // Last resort: ignore user exclusions if no other options
            console.warn(`âš ï¸ [ARTICLE] All articles exhausted, ignoring user exclusions`);
            eligibleArticles = allArticles.filter(article => {
                const neverUsed = !article.used_in_daily && !article.used_in_custom_exam;
                const dailyReusable =
                    article.used_in_daily &&
                    article.last_used_at &&
                    new Date(article.last_used_at) < new Date(cooldownDate);
                return neverUsed || dailyReusable;
            });
        }
    }

    if (eligibleArticles.length === 0) {
        console.error(
            `[ARTICLE] No eligible articles after filtering | genre=${genre}, usage=${usageType}`
        );
        throw new Error(
            `No eligible articles found for genre=${genre}, usage=${usageType}`
        );
    }

    /**
     * STEP 4: Sort to prioritize best candidates
     * 1. Never-used articles (last_used_at is null)
     * 2. Least-used articles by count
     * 3. Oldest last_used_at
     */
    eligibleArticles.sort((a, b) => {
        // Prioritize never-used
        const aUsed = a.last_used_at !== null;
        const bUsed = b.last_used_at !== null;
        if (aUsed !== bUsed) return aUsed ? 1 : -1;

        // Then by usage count
        const aCount = usageType === "daily"
            ? (a.custom_exam_usage_count ?? 0)
            : (a.daily_usage_count ?? 0);
        const bCount = usageType === "daily"
            ? (b.custom_exam_usage_count ?? 0)
            : (b.daily_usage_count ?? 0);

        if (aCount !== bCount) return aCount - bCount;

        // Then by oldest last_used_at
        if (!a.last_used_at) return -1;
        if (!b.last_used_at) return 1;
        return new Date(a.last_used_at).getTime() - new Date(b.last_used_at).getTime();
    });

    const selectedArticle = eligibleArticles[0];

    console.log(
        "ðŸ“˜ [ARTICLE] Article selected:",
        selectedArticle.title,
        "|",
        selectedArticle.url
    );

    /**
     * STEP 5: Update usage metadata
     */
    const updatePayload =
        usageType === "daily"
            ? {
                used_in_daily: true,
                daily_usage_count:
                    (selectedArticle.daily_usage_count ?? 0) + 1,
                last_used_at: now,
                updated_at: now,
            }
            : {
                used_in_custom_exam: true,
                custom_exam_usage_count:
                    (selectedArticle.custom_exam_usage_count ?? 0) + 1,
                last_used_at: now,
                updated_at: now,
            };

    const { error: updateError } = await supabase
        .from("articles")
        .update(updatePayload)
        .eq("id", selectedArticle.id);

    if (updateError) {
        console.error("[ARTICLE] Update error:", updateError);
        throw new Error(
            `Failed to update article usage: ${updateError.message}`
        );
    }

    /**
     * STEP 6: Return selected article
     */
    return {
        articleMeta: selectedArticle,
        semantic_ideas: selectedArticle.semantic_ideas_and_persona.semantic_ideas,
        authorial_persona: selectedArticle.semantic_ideas_and_persona.authorial_persona,
    };
}
